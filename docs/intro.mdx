---
title: Intro to Functor
sidebar_position: 1
slug: /
---

<Head>
  <meta prefix="og: http://ogp.me/ns#" />
</Head>

## What is Functor[^1] Network?

[^1]: The mathematically inclined reader might be already relating the mathematical concept of a [functor](https://en.wikipedia.org/wiki/Functor) with our solution. *We bridge the gap between the category of AIs and of decentralized systems*.

**Functor Network** by [Security Labs](https://node.securitylabs.xyz/), at its core, is a **minimal keystore (KS) network**. 

<!-- :::info[Who is [Security Labs](https://node.securitylabs.xyz/)]
[Security Labs](https://node.securitylabs.xyz/) is shaping the key management abstraction scene by building Functor Network and a set of standards to bridge the gap between artificial intelligence and blockchain technologies with the aim of securely achieve the chain abstracted future.
::: -->

A **minimal keystore layer** is a cross-chain [key/value store](/concepts/glossary/#key-value-store) for smart wallet keys, [session keys](/concepts/glossary/#session-key) and other configurations. It is **minimal** in that its nodes need only to manage this simple [key/value database](/concepts/glossary/#key-value-store), and not balances nor smart contracts. This has the following simple consequences:

- **Nodes are [lightweight](/concepts/glossary/#light-node)**: This means they can be run in lightweight devices such as raspberry pis, mobile apps and web browser extensions. This is thanks to being designed as a [modular blockchain](/concepts/glossary/#modular-blockchain)[^2], as well as its [execution client](/concepts/glossary/#execution-client) being ultra-specialized to just the task of holding Smart Contract Wallet configurations and nothing more.

[^2]: Where responsibilities of [consensus](/concepts/glossary/#consensus-client), [data availability](/concepts/glossary/#data-availability) and [execution](/concepts/glossary/#execution-client) are <u>separated modularly</u>.

- **Its simple state is readable from everywhere**: Due to the simplicity of its state, fast updates (through zero-knowledge proofs) and verifications can be done across any L2 through syncing keystore smart contracts on each L2. For censorship-resistance, it's also possible to [force include](/concepts/glossary/#force-inclusion) directly to the keystore smart contract on the L1.

## Why Functor Network?

In practice, **Functor Network** acts as a **unified access layer for the autonomous world**. 

This means that, in order for the unavoidable intersection of **Artificial intelligence (AI)** and **blockchain** through **on-chain AI agents** to untap markets across use cases such as:

- High speed & complex automatic trading with cross-chain liquidity
- Decentralized SaaS products with automatic & secure payment options, better customized based on consumer's behaviour.
- Richer intent engines with collaboration of multiple AI agent/oracles.
- AI-based dApps automation.

We need first an infrastructure for these AI agents to act **verifiably**, **collaboratively** and **chain-agnostically**. To understand why these **are not** possible today, let's highlight the following limitations:

1. **Automation and transaction scheduling is <u>inconvenient</u> or <u>insecure</u>:** Today, for an AI agent to act on-chain, it requires either their own wallet with funds (inconvenient and more costly) or access to a signing key to produce transactions over our assets (insecure). 

2. **AI agents aren't perfect:** We know AI can't be ever perfect: It [hallucinates](https://en.wikipedia.org/wiki/Hallucination_(artificial_intelligence)) and give false positives/negatives. For it to be safely used, their computation must be verifiable cryptographically.

3. **Web3 is still fragmented:** To <u>*realistically*</u> automatize much of Web3 core processes, We need to first solve fragmentations such as liquidity across L2s, the need of having one wallet per chain and trust-less cross-chain [atomic transactions](/concepts/glossary/#atomic-transaction) (mainly for safe DeFi applications).

## How is Functor solving it?

At a high level, all an AI-agent is doing is:

1. **Reading** some data
2. Acting on a system, **changing** its state
3. New data is **produced** from changed state

![AI agent](/img/ai_agent.png)

All of this with some objective, sometimes as simple as buying a token at some price (need to act only once) or to maintain a portfolio in optimum market performance (which needs an ongoing agent, reading new data constantly). 

**The critical piece in this process is when AI agent changes the state of the blockchain**.

Issue (1) of **"scheduling and automatizing transactions"** safely requires AI agents to have, not *full permissions* over a wallet, but only granular, temporary permissions. This is achieved through [**session keys**](/concepts/glossary/#session-key), which:

- Gives the AI agent a **signing key** to produce transactions.
- Gives the blockchain a **configuration** to **cryptographically verify** transactions attempted by the AI over our assets. Solving here issue (2) of **"AI's hallucinations"**, through active on-chain verification.

This configuration file must be **cross-chain** in order to also solve issue (3) of **"Fragmentation in Web3"**. Functor, as a Keystore network, allows these configurations to be readable in a chain-agnostic way.

An example of how AI agents work with Functor sesions is as follows:

![AI agent UX](/img/ai_agent_ux.png)

A user or dApp can configure any agent with as much permissions as they want, during some timeframe. This AI agent will then only act as described, becoming **predictable** for the user, dApp and *— critically — other AI agents too.*

AI agents being predictable, and also variably so, for other AI agents allow them to collaborate in a safe manner; making them **composable**. Consider the following example:

![Multi agent session](/img/multi_agent_session.png)

To assets, **A1** and **A2**, are being used by independent AI agents, possibly on different chains, and reading different data they don't need to be sharing. 

A third session configurating the **relationship** between **A1** and **A2** is created. This will make it so **A2** can't be used until **A1** is moved first, making it possible to force a sequential constraint over AI actions <u>without the need of cross-chain communication</u>.

## Who Can Use Functor Network?

1. **AI Agents and Autonomous Systems**:
   - AI agents benefit from Functor Network’s support of **session keys** and **intents engines** to autonomously execute transactions and manage assets across multiple chains, ensuring secure and efficient operations.

2. **dApp Developers and Blockchain Innovators**:
   - Developers building decentralized applications can leverage Functor Network’s keystore for seamless **dApp interoperability**. This enables dApps to share and enforce permissions across chains, enhancing cross-chain functionality and usability.

3. **Web3 Users and Institutions**:
   - Web3 users transitioning from traditional web2 applications can enjoy simplified **key and credential management**, with secure synchronization across chains. Functor Network’s **intents engines** also reduce user friction, making it easier to navigate decentralized ecosystems.

4. **Cross-Chain Service Providers**:
   - Service providers can use Functor Network’s keystore to build cross-chain applications, enabling interoperability and shared permissions between their services across multiple blockchains.
